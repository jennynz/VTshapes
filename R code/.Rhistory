allSpeakers.df
unlist(allSpeakers.df[89,-(1:2)])
plot (c(0,29),c(0,300),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 had vowel area functions")
legend(0,40,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1))
00),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 had vowel area functions")
legend(0,40,c("Inte
plot (c(0,29),c(0,500),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 had vowel area functions")
legend(0,40,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1))
plot (c(0,29),c(0,500),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 had vowel area functions")
legend(0,40,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1))
plot (c(0,29),c(0,600),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 had vowel area functions")
legend(0,80,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1))
plot (c(0,29),c(0,650),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 had vowel area functions")
legend(0,100,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1))
plot (c(0,29),c(0,700),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 had vowel area functions")
legend(0,100,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1))
title(main = "VT09 'had' vowel area functions")
plot (c(0,29),c(0,300),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[14,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[2],"distance_area","head.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT02 'head' vowel area functions")
legend(0,40,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1))
# VT09 had: Comparing linearly interpolated area function with raw distance_area txt from MATLAB
plot (c(0,29),c(0,700),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 'had' vowel area functions")
legend(0,100,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1))
help(legend)
legend(0,100,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1), col=par("col"))
legend(0,100,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1), col=par("col"))
legend(0,100,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1), col=c("red","blue"))
plot (c(0,29),c(0,700),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
lines(vt02e[,2], col="blue")
title(main = "VT09 'had' vowel area functions")
legend(0,100,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1), col=c("red","blue"))
graphics.off() # close all graphics windows
plot (c(0,29),c(0,300),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[14,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[2],"distance_area","head.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT02 'head' vowel area functions")
legend(0,40,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1), col=c("red","blue"))
# VT09 had: Comparing linearly interpolated area function with raw distance_area txt from MATLAB
plot (c(0,29),c(0,700),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 'had' vowel area functions")
legend(0,100,c("Interpolated on R and MATLAB","Interpolated in MATLAB only"), lty=c(1,1), col=c("red","blue"))
plot (c(0,29),c(0,300),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[14,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[2],"distance_area","head.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT02 'head' vowel area functions")
legend(0, 40, c("Interpolated on R","Raw area function"), lty=c(1,1), col=c("red","blue"))
# VT09 had: Comparing linearly interpolated area function with raw distance_area txt from MATLAB
plot (c(0,29),c(0,700),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 'had' vowel area functions")
legend(0, 100, c("Interpolated on R","Raw area function"), lty=c(1,1), col=c("red","blue"))
cor.test(pc.VTareas$x[,1],pc.resfreqIV$x[,1])
pca
pca <- NULL
for(i in numVTs){
spk <- VTlist[i]
spkData <- allSpeakers.df[grep(spk, allSpeakers.df$spk),4:30]
spkPCA <- prcomp(~., data=na.omit(allSpeakers.df[,4:30]/maxArea), scale=T)
pca[i] <- spkPCA
}
pca[1]
allSpeakers.df
allSpeakers.df[1:11,4:30]
vt1pca <- prcomp(~., data=na.omit(allSpeakers.df[1:11,4:30]/maxArea), scale=T)
vt2pca <- prcomp(~., data=na.omit(allSpeakers.df[12:22,4:30]/maxArea), scale=T)
vt1pca
levels(vt1pca)
vt1pca$rotation
cor.test(vt1pca$rotation, vt2pca$rotation)
vt1pca$rotation[,1]
vt2pca$rotation[,1]
cor.test(vt1pca$rotation[,1], vt2pca$rotation[,1])
cor.test(vt1pca$rotation[,1], vt1pca$rotation[,1])
plot(vt2pca$rotation[,1])
lines(vt1pca$rotation[,1])
plot (c(0,29),c(0,300),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(vt1pca$rotation[,1], col="red")
lines(vvt2pca$rotation[,1], col="blue")
title(main = "PC1 for VT01 and VT02 area function data points")
legend(0, 40, c("VT01","VT02"), lty=c(1,1), col=c("red","blue"))
plot(type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(vt1pca$rotation[,1], col="red")
lines(vvt2pca$rotation[,1], col="blue")
title(main = "PC1 for VT01 and VT02 area function data points")
legend(0, 40, c("VT01","VT02"), lty=c(1,1), col=c("red","blue"))
plot(type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
plot(c(0,28),c(0,0.5),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
plot(c(0,28),c(0,0.5),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(vt1pca$rotation[,1], col="red")
lines(vvt2pca$rotation[,1], col="blue")
title(main = "PC1 for VT01 and VT02 area function data points")
legend(0, 40, c("VT01","VT02"), lty=c(1,1), col=c("red","blue"))
plot(c(0,28),c(-0.5,0.5),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(vt1pca$rotation[,1], col="red")
lines(vvt2pca$rotation[,1], col="blue")
title(main = "PC1 for VT01 and VT02 area function data points")
legend(0, 40, c("VT01","VT02"), lty=c(1,1), col=c("red","blue"))
plot(c(0,28),c(-0.5,0.5),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(vt1pca$rotation[,1], col="red")
lines(vt2pca$rotation[,1], col="blue")
title(main = "PC1 for VT01 and VT02 area function data points")
legend(0, 40, c("VT01","VT02"), lty=c(1,1), col=c("red","blue"))
plot(c(0,28),c(-0.4,0.4),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(vt1pca$rotation[,1], col="red")
lines(vt2pca$rotation[,1], col="blue")
title(main = "PC1 for VT01 and VT02 area function data points")
legend(0, -0.3, c("VT01","VT02"), lty=c(1,1), col=c("red","blue"))
cor.test(vt1pca$rotation[,1], vt2pca$rotation[,1])
source('~/Part IV Project/R code/readAreaFunctions_1Set.R', echo=TRUE)
.libPaths('H:/Documents/Rlibraries')
library('emuR')
# Normalise for maximum area in each shape to eliminate interspeaker effects
# Excluding first column X1 because of unreliability of first frame of MRI images (lips are usually poorly defined), and last column X29
# e.g. VT09 shapes much bigger than others.
maxArea=apply(allSpeakers.df[,4:30],1,max)
pca <- prcomp(~., data=na.omit(allSpeakers.df[,4:30]/maxArea), scale=T)
pca.summ <- summary(pca)
levels(allSpeakers.df$vow) <- c("æ", "ɑː", "e", "iː", "ɜː", "ɪ", "ɔː", "ɒ", "ʊ", "ʌ", "uː")
colpalette <- c("firebrick4","chocolate4","darkgoldenrod","chartreuse4","aquamarine4","darkcyan","deepskyblue4","darkslateblue","darkorchid4","deeppink4","indianred4")
# Plot of PC1 and PC2, all vowels
eplot(pca$x[,1:2], labs=as.character(allSpeakers.df[,2]), centroid=F, formant=T, col=colpalette, doellipse = T, dopoints = T)
title(main = "Vowel properties (12 VTs x 1 Sets)", xlab = "PC1", ylab = "PC2")
# Compare with old 12VT1Set plot where hood was huddled in corner.
eplot(pca$x[,1:2], labs=as.character(allSpeakers.df[,2]), centroid=F, formant=T, col=colpalette, doellipse = F, dopoints = T, xlim = c(-6,6), ylim = c(-6, 6))
title(main = "Vowel properties (12 VTs x 1 Sets)", xlab = "PC1", ylab = "PC2")
# Plot of PC1 and PC2, centroids only
eplot(pca$x[,1:2], labs=as.character(allSpeakers.df[,2]), centroid=T, formant=T, col=colpalette, doellipse = T)
title(main = "Centroids of combined vowel properties (12 VTs x 1 Set)", xlab = "PC1", ylab = "PC2")
# Plot of standard deviations
plot(pca$sdev, type="p", xlab="Principal component #", ylab="Standard deviation")
title(main = "Standard deviations of principal components from combined dataset (12 VTs x 1 Set)")
# Plot of proportions of variance
pca.var <- pca.summ$importance[2,]
plot(pca.var, type="p", xlab="Principal component #", ylab="% Variance")
title(main = "Proportion of variance explained by principal components (12 VTs x 1 Set)")
# VT02 head: Comparing linearly interpolated area function with raw distance_area txt from MATLAB
plot (c(0,29),c(0,300),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[14,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[2],"Set1","distance_area","head.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT02 'head' vowel area functions")
legend(0, 40, c("Interpolated on R","Raw area function"), lty=c(1,1), col=c("red","blue"))
# VT09 had: Comparing linearly interpolated area function with raw distance_area txt from MATLAB
plot (c(0,29),c(0,700),type="n", xlab="Data point", ylab="Cross-sectional area (mm^2)")
lines(unlist(allSpeakers.df[89,-(1:2)]), col="red")
vt02e <- read.table(paste(path,VTlist[9],"Set1","distance_area","had.txt",sep="\\"))
lines(vt02e[,2], col="blue")
title(main = "VT09 'had' vowel area functions")
legend(0, 100, c("Interpolated on R","Raw area function"), lty=c(1,1), col=c("red","blue"))
setwd("~/Part IV Project/R code")
source('~/Part IV Project/R code/readAreaFunctions_2Reps.R', echo=TRUE)
# Number of principal components to test
np <- 3
vars <- matrix(data = NA, nrow = numVTs, ncol = np+1, byrow = TRUE)
colnames(vars) <- c("PC1+PC2", paste("PC", 1:np, sep=""))
rownames(vars) <- VTlist
vars <- matrix(data = NA, nrow = 2, ncol = np+1, byrow = TRUE)
colnames(vars) <- c("PC1+PC2", paste("PC", 1:np, sep=""))
rownames(vars) <- c("Rep 1", "Rep 2")
isNorm <- T
allSpeakers.df()
allSpeakers.df[,2:30]
allSpeakers.df[,2:29]
allSpeakers.df[,4:30]
allSpeakers.df <- compileMRIAreas()
allSpeakers.df
allSpeakers.df[2:30]
allSpeakers.df[3:29]
if (isNorm == T) { maxArea <- apply(allSpeakers.df[,3:29],1,max) }
allSpeakers.df
maxArea
2:2:4
2:1:4
2:4:16
seq(2,8,2)
seq(1,8,2)
maxArea[seq(1,numVowels,2)]
maxArea[seq(2,numVowels,2)]
maxArea
paste("Rep", 1:r, sep=" ")
r <- 2
r <- 2
paste("Rep", 1:r, sep=" ")
allSpeakers.df[,3:29]/maxArea
maxArea
allSpeakers.df
a <- 1:20
a
a[seq(1,18,3)]
a[seq(2,18,3)]
a[seq(3,18,3)]
1:nr
vars
# Number of repetitions
nr <- 2
# Number of principal components to test
np <- 3
# Table for variances
vars <- matrix(data = NA, nrow = nr, ncol = np+1, byrow = TRUE)
colnames(vars) <- c("PC1+PC2", paste("PC", 1:np, sep=""))
rownames(vars) <- paste("Rep", 1:nr, sep=" ")
vars
corr <- matrix(data = NA, nrow = np, ncol = 2, byrow = TRUE)
colnames(corr) <- c("Correlation", "P-value")
rowlist <- 0
for (i in 1:np) {
rowlist[i*2-1] <- paste("PC", i, " Corr", sep="")
rowlist[i*2] <- paste("PC", i, " P-value", sep="")
}
rownames(corr) <- rowlist
corr
corr <- matrix(data = NA, nrow = np, ncol = 2, byrow = TRUE)
colnames(corr) <- c("Correlation", "P-value")
rownames(corr) <- paste("PC", 1:np, sep="")
corr
vars[r,1] <- summary(pca)$importance[2,1] + summary(pca)$importance[2,2]
pca <- prcomp(~., data = allSpeakers.df[seq(r,numVowels,nr),3:29], scale=T)
vars[r,1] <- summary(pca)$importance[2,1] + summary(pca)$importance[2,2]
pca$x
b<=pca$x
b<-pca$x
b
b[,2]
b[1]<-pca$x
c[1]<-pca$x
c <- data.frame(pca$x)
c
c[1] <- data.frame(pca$x)
d[1] <- data.frame(pca$x)
corrdata <- data.frame()
corrdata[1] <- c
?data.frame
corrdata <- data.frame(row.names=paste("Rep", 1:nr, sep=" "))
corrdata
corrdata <- data.frame(...,row.names=paste("Rep", 1:nr, sep=" "))
corrdata <- data.frame(data = NA, row.names=paste("Rep", 1:nr, sep=" "))
corrdata <- data.frame(data = NA, nrow = nr, row.names=paste("Rep", 1:nr, sep=" "))
corrdata <- data.frame(row.names=paste("Rep", 1:nr, sep=" "))
corrdata[1] <- c
corrdata
typeof(pca$x)
d <- pca$x
d <- []
corrdata <- list()
corrdata
corrdata[r] <- pca$x
corrdata[r] <- append(list(pca$x
list1 <- list(a = 2, b = 3)
list2 <- list(c = "a", d = "b")
mylist <- list(list1, list2)
list1 <- list(a = 2, b = 3)
list2 <- list(c = "a", d = "b")
mylist <- list(list1, list2)
list1
list2
mylist
list1 <- list(a = 2, b = 3)
list2 <- list(c = "a", d = "b")
mylist <- list(list1, list2)
mylist[[1]]
mylist <- list()
mylist <- list(mylist, list(pca$x))
mylist
mylist[[2]]
r <-2
pca <- prcomp(~., data = allSpeakers.df[seq(r,numVowels,nr),3:29], scale=T)
mylist <- list(mylist, list(pca$x))
mylist
mylist[3] <- list(pca$x)
mylist
mylist <- list()
mylist[3] <- list(pca$x)
mylist
mylist[[3]]
source('~/Part IV Project/R code/readAreaFunctions_2Reps.R', echo=TRUE)
# Assumes 1 VT but could modify to accommodate more.
# Number of repetitions. Currently assumes 2.
nr <- 2
# Number of principal components to test
np <- 3
# Table for variances
vars <- matrix(data = NA, nrow = nr, ncol = np+1, byrow = TRUE)
colnames(vars) <- c("PC1+PC2", paste("PC", 1:np, sep=""))
rownames(vars) <- paste("Rep", 1:nr, sep=" ")
# Table for correlations
corr <- matrix(data = NA, nrow = np, ncol = 2, byrow = TRUE)
colnames(corr) <- c("Correlation", "P-value")
rownames(corr) <- paste("PC", 1:np, sep="")
# Normalise?
isNorm <- T
# Maximum areas for normalising. X1 is omitted since it is unreliable (MRI
# showed little of mouth opening at front of lips) and X29 omitted since it is
# the glottis which is always zero.
if (isNorm == T) {
maxArea <- apply(allSpeakers.df[,3:29],1,max)
allSpeakers.df[,3:29]/maxArea
}
corrdata <- list()
for (r in 1:nr) {
# PCA on each repetition as a group
pca <- prcomp(~., data = allSpeakers.df[seq(r,numVowels,nr),3:29], scale=T)
# Variances
vars[r,1] <- summary(pca)$importance[2,1] + summary(pca)$importance[2,2]
vars[r,-1] <- unname(summary(pca)$importance[2,1:np])
# Save data for correlations
corrdata[r] <- list(pca$x)
}
corrdata
corrdata[[1]][,1]
cor <- cor.test(corrdata[[1]][,p], corrdata[[2]][,p])
corr
for (p in 1:np) {
# Hard-coded r = 2
cor <- cor.test(corrdata[[1]][,p], corrdata[[2]][,p])
# Write to tables
corr[p,1] <- unname(cor$estimate)
corr[p,2] <- unname(cor$p.value)
}
## Variance and correlation analyses for quantifying variability in methods
# Analyses between repetitions of the same vowels for the same speaker to
# quantify variability in manually marking up MRI images. Currently hard-coded
# (in the for loops) for only two repetitions, but may be generalised if time
# allows.
# Written by Jenny Sahng
# 13/09/2016
source('~/Part IV Project/R code/readAreaFunctions_2Reps.R', echo=TRUE)
# Assumes 1 VT but could modify to accommodate more.
# Number of repetitions. Currently assumes 2.
nr <- 2
# Number of principal components to test
np <- 3
# Table for variances
vars <- matrix(data = NA, nrow = nr, ncol = np+1, byrow = TRUE)
colnames(vars) <- c("PC1+PC2", paste("PC", 1:np, sep=""))
rownames(vars) <- paste("Rep", 1:nr, sep=" ")
# Table for correlations
corr <- matrix(data = NA, nrow = np, ncol = 2, byrow = TRUE)
colnames(corr) <- c("Correlation", "P-value")
rownames(corr) <- paste("PC", 1:np, sep="")
# Normalise?
isNorm <- T
# Maximum areas for normalising. X1 is omitted since it is unreliable (MRI
# showed little of mouth opening at front of lips) and X29 omitted since it is
# the glottis which is always zero.
if (isNorm == T) {
maxArea <- apply(allSpeakers.df[,3:29],1,max)
allSpeakers.df[,3:29]/maxArea
}
corrdata <- list()
for (r in 1:nr) {
# PCA on each repetition as a group
pca <- prcomp(~., data = allSpeakers.df[seq(r,numVowels,nr),3:29], scale=T)
# Variances
vars[r,1] <- summary(pca)$importance[2,1] + summary(pca)$importance[2,2]
vars[r,-1] <- unname(summary(pca)$importance[2,1:np])
# Save data for correlations
corrdata[r] <- list(pca$x)
}
# Correlations between all PCs
for (p in 1:np) {
# Hard-coded r = 2
cor <- cor.test(corrdata[[1]][,p], corrdata[[2]][,p])
# Write to tables
corr[p,1] <- unname(cor$estimate)
corr[p,2] <- unname(cor$p.value)
}
vars
corr
corrdata
allSpeakers.df
rss
write.csv(vars, file = paste("vars_normalised.csv", sep=""))
rep1 <- allSpeakers.df[seq(1,numVowels,nr)]
rep2 <- allSpeakers.df[seq(2,numVowels,nr)]
rep1
rep2
allSpeakers.df[seq(r,numVowels,nr),3:29]
rep1 <- allSpeakers.df[seq(1,numVowels,nr),]
rep2 <- allSpeakers.df[seq(2,numVowels,nr),]
rep1
rep2
list()
rss <- 1:4
rss
rep1[1,]
rep1[1,3:29]
rep1[1,3:29] - rep2[1,3:29]
rep2
rep1 <- allSpeakers.df[seq(1,numVowels,nr),]
rep2 <- allSpeakers.df[seq(2,numVowels,nr),]
rss <- 1:4
for (v in rss) {
rss[v] <- rep1[v,3:29] - rep2[v,3:29]
}
rss
rep2 <- allSpeakers.df[seq(2,numVowels,nr),]
rss <- vector()
for (v in rss) {
rss[v] <- c(rss, rep1[v,3:29] - rep2[v,3:29])
}
rss
c(rss, rep1[v,3:29] - rep2[v,3:29])
rss[v] <- c(rss, (rep1[v,3:29] - rep2[v,3:29]))
rss
rep1 <- allSpeakers.df[seq(1,numVowels,nr),]
rep2 <- allSpeakers.df[seq(2,numVowels,nr),]
rss <- vector()
for (v in rss) {
rss[v] <- c(rss, (rep1[v,3:29] - rep2[v,3:29]))
}
rss
rep1 <- allSpeakers.df[seq(1,numVowels,nr),]
rep2 <- allSpeakers.df[seq(2,numVowels,nr),]
rss <- vector()
for (v in rss) {
rss <- c(rss, (rep1[v,3:29] - rep2[v,3:29]))
}
rss
rep1 <- allSpeakers.df[seq(1,numVowels,nr),]
rep2 <- allSpeakers.df[seq(2,numVowels,nr),]
rss <- vector()
for (v in rss) {
rss[v] <- rep1[v,3:29] - rep2[v,3:29]
}
rss
rep1 <- allSpeakers.df[seq(1,numVowels,nr),]
rep2 <- allSpeakers.df[seq(2,numVowels,nr),]
rss <- 1:4
for (v in rss) {
rss[v] <- rep1[v,3:29] - rep2[v,3:29]
}
3**22
3**2
(rep1[v,3:29] - rep2[v,3:29])**2
rep1[v,3:29] - rep2[v,3:29]
rep1[1,3:29]
rep2[1,3:29]
rep4[1,3:29]
rep1[4,3:29]
rep2[4,3:29]
rep1 <- allSpeakers.df[seq(1,numVowels,nr),]
rep2 <- allSpeakers.df[seq(2,numVowels,nr),]
rss <- 1:4
for (v in rss) {
rss[v] <- sum((rep1[v,3:29] - rep2[v,3:29])**2)
}
rss
corr
cor
lmFit <- lm(rep1 ~ rep2)
rep1
lmFit <- lm(rep1[v,3:29] ~ rep2[v,3:29])
rep1[v,3:29]
unlist(rep1[v,3:29])
unname(rep1[v,3:29])
unlist(unname(rep1[v,3:29]))
model <- lm(unlist(unname(rep1[v,3:29])), unlist(unname(rep2[v,3:29])))
rep1 <- allSpeakers.df[seq(1,numVowels,nr),]
rep1
rep1 <- unname(unlist(allSpeakers.df[seq(1,numVowels,nr),]))
rep2 <- unname(unlist(allSpeakers.df[seq(2,numVowels,nr),]))
rep1
rep2
rep1 <- unlist(unname(allSpeakers.df[seq(1,numVowels,nr),]))
rep2 <- unlist(unname(allSpeakers.df[seq(2,numVowels,nr),]))
rep1
vars
corr
rbind(vars,corr)
